# Day 1-2 核心基礎搭建（含 RAG 文件庫）- 完整開發規劃

***

## 📋 總目標與核心產出

### 總目標
建立可運行的對話框架，**整合 RAG 文件檢索能力**，實現基於知識庫的智能旅遊推薦

### 核心產出清單
- [Ｘ] 完整的開發環境（LangChain + LangGraph + OpenAI API + Chroma）
- [Ｘ] **小型旅遊文件庫（3-5 份文件）**
- [Ｘ] **向量資料庫建置（Chroma）**
- [Ｘ] State Schema 定義（含 RAG 欄位）
- [Ｘ] **RAG 檢索節點實作**
- [] LLM 推論節點實作（整合文件）
- [] **完整 RAG Graph 架構（START → RAG → LLM → END）**
- [] InMemoryStore 短期記憶機制
- [] 命令列互動介面（CLI）
- [] 完整測試套件
- [] **可執行的知識增強對話原型**


## 📂 完整專案結構預覽

```
travel_agent_mvp/
├── venv/                       # 虛擬環境
├── documents/                  # 🆕 文件庫
│   ├── taipei_attractions.txt  # 台北景點
│   ├── tokyo_attractions.txt   # 東京景點
│   ├── travel_tips.txt         # 旅遊小貼士
│   ├── budget_guide.txt        # 預算指南
│   └── transportation.txt      # 交通資訊
├── chroma_db/                  # 🆕 向量資料庫
│   └── (Chroma 自動產生的資料檔案)
├── .env                        # 環境變數配置
├── .gitignore                  # Git 忽略檔案
├── requirements.txt            # 依賴清單
├── prepare_documents.py        # 🆕 文件準備腳本
├── build_vectorstore.py        # 🆕 向量庫建置腳本
├── state.py                    # State Schema（含 RAG 欄位）
├── nodes.py                    # Graph Nodes（含 RAG 節點）
├── graph.py                    # Graph 建構（RAG 流程）
├── main.py                     # CLI 執行入口
└── test_agent.py               # 單元測試
```

***

## 📦 階段一：環境準備與基礎架構（1小時）

### 工作任務 1.1：開發環境設定（30分鐘）

**任務目標**：建立完整的開發環境，包含 RAG 相關套件

**核心套件清單**：
```bash
# 基礎框架
langchain              # LangChain 核心
langgraph              # LangGraph 流程編排
langchain-openai       # OpenAI 整合

# 🆕 RAG 相關套件
langchain-community    # 文件載入器
chromadb              # 向量資料庫
tiktoken              # Token 計算

# 工具套件
python-dotenv         # 環境變數管理
```

**執行步驟**：
- [X] 建立專案目錄 `travel_agent_mvp`
- [X] 建立並啟動 Python 虛擬環境（Python >= 3.10）
- [X] 安裝所有核心套件（一次完成）
- [X] 產生 `requirements.txt` 依賴清單
- [X] 驗證所有套件可正常 import

**驗證標準**：
- ✅ 虛擬環境已啟動
- ✅ 所有套件安裝成功無錯誤
- ✅ 可成功 import langchain, langgraph, chromadb
- ✅ requirements.txt 已產生

***

### 工作任務 1.2：專案結構規劃（15分鐘）

**任務目標**：建立完整的專案檔案結構

**執行步驟**：
- [X] 建立所有必要的資料夾
  - [X] `documents/` - 文件庫資料夾
  - [X] `chroma_db/` - 向量資料庫（之後自動產生）
- [X] 建立所有 Python 檔案（空檔案）
  - [X] `state.py`, `nodes.py`, `graph.py`, `main.py`, `test_agent.py`
  - [Ｘ] **`prepare_documents.py`** - 文件準備腳本
  - [Ｘ] **`build_vectorstore.py`** - 向量庫建置腳本
- [X] 建立 `.gitignore` 檔案
  - 排除：`venv/`, `.env`, `__pycache__/`, `*.pyc`, `chroma_db/`

**驗證標準**：
- ✅ 所有資料夾已建立
- ✅ 所有檔案已建立
- ✅ 專案結構清晰

***

### 工作任務 1.3：環境變數設定（15分鐘）

**任務目標**：配置 OpenAI API 與 Agent 參數

**配置項目清單**：
- [X] 建立 `.env` 檔案
- [X] 設定 OpenAI 配置
  - `OPENAI_API_KEY` - 從 OpenAI 取得
  - `OPENAI_MODEL` - 建議：gpt-4o-mini
- [X] 設定 Agent 配置
  - `AGENT_NAME` - 旅遊規劃助理
  - `AGENT_LANGUAGE` - 繁體中文
- [X] 🆕 設定 RAG 配置
  - `EMBEDDING_MODEL` - text-embedding-3-small
  - `CHUNK_SIZE` - 500
  - `CHUNK_OVERLAP` - 50
  - `RETRIEVAL_K` - 3
- [X] 設定開發配置
  - `DEBUG_MODE` - False

**驗證標準**：
- ✅ .env 檔案已建立
- ✅ 環境變數可正確讀取
- ✅ OpenAI API Key 有效
- ✅ .env 已加入 .gitignore

***

## 📚 階段二：文件庫準備與向量資料庫建置（1.5-2小時）

### 工作任務 2.1：文件內容規劃與準備（40分鐘）

**任務目標**：準備 3-5 份高品質的旅遊知識文件

**文件規劃清單**：

| 檔案名稱 | 內容主題 | 字數建議 | 關鍵內容 |
|---------|---------|---------|---------|
| `taipei_attractions.txt` | 台北景點介紹 | 400-600字 | 故宮、101、夜市、陽明山（含營業時間、門票、交通） |
| `tokyo_attractions.txt` | 東京景點介紹 | 400-600字 | 淺草寺、晴空塔、秋葉原（含交通方式、推薦時段） |
| `travel_tips.txt` | 旅遊實用貼士 | 300-500字 | 最佳季節、必備物品、注意事項、禮儀 |
| `budget_guide.txt` | 預算規劃指南 | 400-600字 | 經濟/中等/豪華等級建議、省錢技巧 |
| `transportation.txt` | 交通資訊 | 300-500字 | 機場到市區、市內交通、交通卡使用 |

#### 步驟 1：建立文件庫資料夾與檔案
- 確認 `documents/` 資料夾已存在
- 建立以下 5 個 .txt 檔案：
  - `taipei_attractions.txt`
  - `tokyo_attractions.txt`
  - `travel_tips.txt`
  - `budget_guide.txt`
  - `transportation.txt`

#### 步驟 2：準備每份文件內容
- 每份文件 300-600 字，UTF-8 編碼
- 內容結構化（標題、分段、關鍵字明確）
- 可用下列方法取得內容：
  - 旅遊網站（如背包客棧、痞客邦）
  - ChatGPT 生成（如：「撰寫台北旅遊景點介紹，400字，包含營業時間和交通方式」）
  - 維基百科整理
  - 自己撰寫旅遊經驗

#### 步驟 3：檢查文件品質
- 確認內容可讀性、資訊完整度
- 檢查 UTF-8 編碼無亂碼
- 每份文件主題明確、資訊豐富

#### 步驟 4：驗證
- 至少 3 份文件已準備（建議 5 份）
- 每份文件 300-600 字
- 文件內容與旅遊相關
- 內容結構清晰

---

**文件格式要求**：
- [Ｘ] 純文字檔案（.txt 格式）
- [Ｘ] UTF-8 編碼
- [Ｘ] 結構化內容（用標題、分段清楚劃分）
- [Ｘ] 包含豐富關鍵字（方便檢索）
- [Ｘ] 每份文件 300-600 字

**內容來源建議**：
- [Ｘ] 方法 1：從旅遊網站（如背包客棧、痞客邦）複製資訊
- [Ｘ] 方法 2：使用 ChatGPT 生成（提示詞：「撰寫台北旅遊景點介紹，400字，包含營業時間和交通方式」）
- [Ｘ] 方法 3：整理維基百科內容
- [Ｘ] 方法 4：自己撰寫旅遊經驗

**執行步驟**：
- [Ｘ] 在 `documents/` 資料夾建立 5 個 .txt 檔案
- [Ｘ] 準備每個檔案的內容（可使用 AI 輔助生成）
- [Ｘ] 確認檔案編碼為 UTF-8
- [Ｘ] 檢查內容品質（可讀性、資訊完整度）

**驗證標準**：
- ✅ 至少 3 份文件已準備（建議 5 份）
- ✅ 每份文件 300-600 字
- ✅ 文件內容與旅遊相關
- ✅ UTF-8 編碼無亂碼
- ✅ 內容結構清晰

***

### 工作任務 2.2：文件載入測試腳本（20分鐘）

**任務目標**：建立腳本測試文件可正常載入

#### 步驟 1：建立 prepare_documents.py 檔案
建立 prepare_documents.py 檔案
#### 步驟 2：實作以下功能：
載入 documents/ 資料夾的所有 .txt 文件
顯示文件數量
顯示每個文件的摘要資訊（檔名、字數、前 50 字）
檢查 UTF-8 編碼問題
統計所有文件總字數

**腳本功能規劃**（針對滑雪主題文件庫）：
- [X] 載入 `documents/` 資料夾的所有文件（如 japan_ski_resorts.txt、ski_travel_tips.txt 等）
- [X] 顯示文件數量
- [X] 顯示每個文件的摘要資訊（檔名、字數、前 50 字）
- [X] 檢查編碼問題（UTF-8）
- [X] 統計總字數

**執行步驟**：
- [X] 建立 `prepare_documents.py` 腳本
- [X] 實作文件載入功能（可用標準 open 或 DirectoryLoader）
- [X] 加入文件統計功能
- [X] 測試執行並檢查輸出

**驗證標準**：
- ✅ 腳本可正常執行
- ✅ 所有滑雪主題文件可正常載入
- ✅ 無編碼錯誤
- ✅ 文件統計資訊正確顯示

***

### 工作任務 2.3：向量資料庫建置（30-40分鐘）

**任務目標**：將文件轉換為向量並儲存到 Chroma

**技術配置**：
- [Ｘ] 向量資料庫：**Chroma**（本地、免費、易用）
- [Ｘ] Embeddings：**OpenAI text-embedding-3-small**（成本低）
- [Ｘ] 文件切割：**RecursiveCharacterTextSplitter**
  - `chunk_size=500`（每段約 500 字元）
  - `chunk_overlap=50`（段落間重疊 50 字元）
- [Ｘ] 持久化目錄：`./chroma_db`
- [Ｘ] Collection 名稱：`travel_knowledge`

**建置流程**：
```
載入文件 
  → 切割成 chunks 
  → 生成 embeddings 
  → 儲存到 Chroma 
  → 持久化到磁碟
```

## 向量資料庫建置（Chroma）開發步驟

### 步驟 1：建立 `build_vectorstore.py` 檔案
- 在專案根目錄新增 `build_vectorstore.py`。

### 步驟 2：載入所有文件
- 使用標準 `open` 或 LangChain 的 `DirectoryLoader` 載入 `documents/` 資料夾的所有 `.txt` 文件。

### 步驟 3：文件切割
- 使用 `RecursiveCharacterTextSplitter` 將每份文件切割為 chunks。
  - `chunk_size=500`
  - `chunk_overlap=50`

### 步驟 4：生成 Embeddings
- 使用 OpenAI 的 `text-embedding-3-small` 產生每個 chunk 的向量。

### 步驟 5：建立 Chroma 向量資料庫
- 將所有 chunks 及其 embeddings 儲存到 Chroma。
- 設定 collection 名稱為 `travel_knowledge`。

### 步驟 6：持久化資料庫
- 設定 Chroma 的持久化目錄為 `./chroma_db`。

### 步驟 7：進度與錯誤處理
- 顯示處理進度（如目前處理到第幾個文件）。
- 加入 API 失敗、檔案錯誤等例外處理。

### 步驟 8：執行與驗證
- 執行腳本，確認 `chroma_db/` 資料夾已產生。
- 檢查所有文件已向量化，無錯誤。

---


**執行步驟**：
- [X] 建立 `build_vectorstore.py` 腳本
- [X] 實作完整建置流程
  - [X] 載入所有文件
  - [X] 切割文件為 chunks
  - [X] 初始化 OpenAI Embeddings
  - [X] 建立 Chroma 向量資料庫
  - [X] 儲存到 `./chroma_db`
- [X] 加入進度顯示（處理了幾個文件）
- [X] 加入錯誤處理（API 失敗、檔案錯誤）
- [X] 執行腳本建置向量庫

**驗證標準**：
- ✅ 腳本執行成功無錯誤
- ✅ `chroma_db/` 資料夾已產生
- ✅ 可看到向量化進度輸出
- ✅ 所有文件已向量化

***

### 工作任務 2.4：向量檢索功能測試（20分鐘）

**任務目標**：測試向量資料庫的檢索功能

**測試項目（滑雪行程規劃主題）**：
- [X] 測試查詢：「推薦日本滑雪場」
  - 預期：檢索到 `japan_ski_resorts.txt` 相關內容
- [X] 測試查詢：「滑雪旅遊貼士」
  - 預期：檢索到 `ski_travel_tips.txt` 相關內容
- [X] 測試查詢：「滑雪預算怎麼規劃」
  - 預期：檢索到 `ski_budget_guide.txt` 相關內容
- [X] 測試查詢：「滑雪交通方式」
  - 預期：檢索到 `ski_transportation.txt` 相關內容
- [X] 測試查詢：「滑雪行程範例」
  - 預期：檢索到 `ski_itinerary_sample.txt` 相關內容
- [X] 驗證檢索數量（每次查詢應返回 3 個結果）
- [X] 驗證檢索結果排序（相關性高者優先）

**執行步驟**：
- [X] 在 `build_vectorstore.py` 加入測試區段
- [X] 載入已建置的向量庫
- [X] 執行多個測試查詢
- [X] 檢查檢索結果的相關性

# TODO
- [ ] 調整參數（如果需要）
什麼時候需要進入參數調整？
1. 檢索結果不理想時
查詢結果與主題不夠相關、檢索到的內容不精準
某些查詢無法返回預期文件或內容
2. 測試覆蓋更多真實使用情境時
增加查詢多樣性（如不同用語、長短句）
發現 chunk 切割太細或太粗，導致檢索效果不佳
3. 文件庫擴充後
新增更多文件或主題，原本參數不再適用
需要調整 chunk_size、chunk_overlap、retrieval_k 等以適應新資料量
4. LLM 整合後發現回應品質不佳
LLM 回應未能充分利用檢索到的文件內容
文件過長或過短影響 prompt 整合效果
5. 使用者回饋或真實場景測試
實際用戶測試後發現某些查詢體驗不佳
需要根據回饋微調參數


**驗證標準**：
- ✅ 向量檢索可正常運作
- ✅ 檢索結果與查詢相關
- ✅ 返回文件數量正確（k=3）
- ✅ 相關性排序合理

***

## 📐 階段三：State Schema 設計（1小時）

### 工作任務 3.1：定義含 RAG 欄位的 State 結構（40分鐘）

**任務目標**：設計支援 RAG 功能的狀態結構

**State 欄位設計**：

| 欄位名稱 | 類型 | 用途 | 是否新增 |
|---------|------|------|---------|
| `messages` | `Annotated[list[AnyMessage], add_messages]` | 對話訊息歷史 | ⬜ 原有 |
| `user_preferences` | `dict` | 使用者偏好（預算、興趣等） | ⬜ 原有 |
| `retrieved_docs` | `list[Document]` | RAG 檢索到的文件 | 🆕 新增 |
| `query` | `str` | 當前查詢字串 | 🆕 新增（可選） |

### 設計原則
- [X] 最小化原則：僅包含必要欄位（messages, user_preferences, retrieved_docs, query）
- [X] 型別安全：使用 TypedDict，所有欄位型別明確
- [X] RAG 整合：retrieved_docs 欄位已加入
- [X] 擴展性：結構清晰，未來可擴充

### 執行步驟
- [X] 在 `state.py` 定義 `AgentState` 類別
- [X] 加入所有必要欄位（含 RAG 欄位）
- [X] 撰寫詳細的 docstring 說明每個欄位（用途、型別、範例值）
- [X] 建立測試用狀態實例（`__main__` 區塊）
- [X] 驗證型別檢查（執行無錯誤，欄位型別正確）

#### 開發步驟

1. **建立 `state.py` 檔案**
   - 在專案根目錄新增 `state.py`。

2. **設計 State Schema**
   - 使用 TypedDict 或 dataclass 定義 `AgentState` 類別。
   - 加入以下欄位：
     - `messages`: Annotated[list[AnyMessage], add_messages]（對話訊息歷史）
     - `user_preferences`: dict（使用者偏好）
     - `retrieved_docs`: list[Document]（RAG 檢索到的文件，新增）
     - `query`: str（當前查詢字串，新增/可選）

3. **撰寫詳細 docstring**
   - 為每個欄位加上用途、型別、範例值的說明。

4. **型別安全設計**
   - 使用 TypedDict 或 dataclass，確保型別檢查。

5. **建立測試用狀態實例**
   - 在 `state.py` 結尾建立一個範例實例，並印出內容驗證。

6. **驗證型別檢查**
   - 執行 `python state.py`，確保無型別錯誤。

**驗證標準**：
- ✅ State Schema 包含所有必要欄位
- ✅ RAG 欄位型別正確
- ✅ Docstring 說明完整
- ✅ 測試實例可正常建立
- ✅ 執行測試無錯誤

***

# TODO
### 工作任務 3.2：State Schema 文檔撰寫（20分鐘）

**任務目標**：撰寫完整的設計文檔

**文檔內容規劃**：
- [Ｘ] 設計原則說明
- [Ｘ] 各欄位詳細說明
  - 用途、類型、範例值、預設值
- [Ｘ] Reducer 機制說明（add_messages 如何運作）
- [Ｘ] RAG 欄位使用說明
  - `retrieved_docs` 何時更新
  - 如何在節點間傳遞
- [Ｘ] 未來擴展欄位預告（Day 3-4）
  - `itinerary`: 規劃的行程
  - `search_results`: 工具搜尋結果
  - `current_step`: 當前執行步驟

**驗證標準**：
- ✅ 文檔完整易懂
- ✅ 範例清晰
- ✅ RAG 使用說明詳細

***

## 🔍 階段四：RAG 檢索節點實作（2小時）

### 工作任務 4.1：初始化向量檢索器（30分鐘）

**任務目標**：建立可重用的向量檢索器實例

**檢索器配置**：
- [X] 載入 Chroma 向量資料庫（從 `./chroma_db`）
- [X] 配置 OpenAI Embeddings（text-embedding-3-small）
- [X] 設定檢索參數
  - `k=3`：返回前 3 個最相關文件
  - `search_type="similarity"`：相似度搜尋
- [X] 建立 Retriever 實例
- [X] 加入錯誤處理（資料庫不存在時的處理）

**執行步驟：**
- [X] 在 `nodes.py` 檔案頂部初始化
- [X] 載入環境變數（如 `RETRIEVAL_K`, `EMBEDDING_MODEL`）
- [X] 初始化 Chroma vectorstore（指定 `persist_directory` 與 `collection_name`）
- [X] 建立 retriever 實例（只需設定 `k`，不需 `search_type`）
- [X] 加入資料庫不存在的錯誤處理（明確提示）
- [X] 測試 retriever 可正常呼叫（可執行查詢並打印結果）


1. **在 `nodes.py` 檔案頂部撰寫初始化程式碼**
   - 載入環境變數（如 `RETRIEVAL_K`、`EMBEDDING_MODEL`）
   - 匯入 Chroma、OpenAIEmbeddings 等必要套件

2. **載入 Chroma 向量資料庫**
   - 指定 `persist_directory="./chroma_db"`
   - 加入錯誤處理（若資料庫不存在則提示）

3. **配置 OpenAI Embeddings**
   - 使用 `.env` 內的 `EMBEDDING_MODEL`（如 `text-embedding-3-small`）
   - 初始化 Embeddings 實例

4. **設定檢索參數**
   - `k=3`：每次查詢返回 3 個最相關文件
   - `search_type="similarity"`：使用相似度搜尋

5. **建立 Retriever 實例**
   - 使用 Chroma 的 `.as_retriever()` 方法
   - 設定參數（如 `search_kwargs={"k": k, "search_type": "similarity"}`）

6. **測試 Retriever 可正常呼叫**
   - 執行一個簡單查詢，確認能正確返回文件

7. **加入詳細註解與錯誤處理**
   - 資料庫不存在時給出明確提示
   - Embeddings 初始化失敗時處理


**驗證標準**：
- ✅ Retriever 可正常初始化
- ✅ 可執行簡單查詢
- ✅ 錯誤處理完善
- ✅ 返回格式正確

***

### 工作任務 4.2：實作 RAG 檢索節點（1小時）

**任務目標**：建立執行文件檢索的節點函數

**節點設計規格**：
- [Ｘ] 函數名稱：`rag_retrieval_node`
- [Ｘ] 輸入：`AgentState`
- [Ｘ] 輸出：`dict` 包含 `retrieved_docs`
- [Ｘ] 職責：從向量資料庫檢索相關文件

**節點邏輯流程**：
```
接收 state 
  → 提取最後一條使用者訊息 
  → 執行向量相似度搜尋 
  → 返回檢索到的文件
```

**功能需求**：
- [Ｘ] 從 `state["messages"]` 提取最後使用者訊息
- [Ｘ] 使用訊息內容作為查詢字串
- [Ｘ] 執行向量檢索（k=3）
- [Ｘ] 返回 Document 物件列表
- [Ｘ] 處理空查詢情況（返回空列表）
- [Ｘ] 處理無結果情況（返回空列表）
- [Ｘ] 加入完整錯誤處理

**執行步驟**：
- [Ｘ] 在 `nodes.py` 實作 `rag_retrieval_node` 函數
- [Ｘ] 實作提取使用者訊息邏輯
- [Ｘ] 實作檢索邏輯
- [Ｘ] 加入邊界情況處理
- [Ｘ] 加入詳細註解說明
- [Ｘ] 建立單元測試函數

### 開發步驟

1. **在 `nodes.py` 檔案中新增 `rag_retrieval_node` 函數**
   - 定義函數名稱：`rag_retrieval_node`
   - 輸入參數：`state`（型別為 AgentState）
   - 輸出：`dict`，包含 `retrieved_docs` 欄位

2. **提取最後一條使用者訊息**
   - 從 `state["messages"]` 遍歷，找到最後一條 `role == "user"` 的訊息
   - 若無使用者訊息，回傳空列表

3. **執行向量檢索**
   - 使用訊息內容作為查詢字串
   - 呼叫 retriever（k=3），取得相關文件

4. **處理空查詢與無結果情況**
   - 查詢字串為空時，回傳空列表
   - 檢索結果為空時，回傳空列表

5. **錯誤處理**
   - 加入 try/except，捕捉 retriever 或資料庫錯誤
   - 回傳空列表並記錄錯誤訊息（可選）

6. **返回結果**
   - 將檢索到的文件以 `retrieved_docs` 欄位包裝成 dict 回傳

7. **加上詳細註解與型別標註**
   - 每個步驟加上註解，方便維護

**驗證標準**：
- ✅ 節點函數可正常執行
- ✅ 返回正確的 Document 列表
- ✅ 空查詢處理正確
- ✅ 錯誤處理完善

***

### 工作任務 4.3：RAG 節點單元測試（30分鐘）

**任務目標**：測試 RAG 節點各種情境

**測試案例規劃**：

| 測試案例 | 輸入 | 預期輸出 |
|---------|------|---------|
| 正常查詢 | 「推薦台北景點」 | 返回 3 個相關文件 |
| 東京查詢 | 「東京有什麼好玩」 | 返回東京相關文件 |
| 預算查詢 | 「怎麼規劃預算」 | 返回預算指南文件 |
| 空查詢 | 空訊息列表 | 返回空列表 |
| 無相關結果 | 「火星旅遊」 | 返回空列表或低相關度文件 |

**測試項目**：
- [X] 正常查詢測試
- [X] 多種主題查詢測試
- [X] 空查詢邊界測試
- [X] 返回文件數量驗證
- [X] 文件內容相關性驗證
- [X] 錯誤處理測試

**執行步驟**：
- [X] 在 `nodes.py` 加入測試區段（`if __name__ == "__main__"`）
- [X] 實作所有測試案例
- [X] 執行測試並檢查輸出
- [X] 調整檢索參數（如果需要）

**驗證標準**：
- ✅ 所有測試案例通過
- ✅ 檢索結果相關性高
- ✅ 邊界情況處理正確
- ✅ 執行 `python nodes.py` 測試通過

***

## 🧠 階段五：LLM 節點實作（2小時）

### 工作任務 5.1：更新 LLM 節點以整合 RAG（1.5小時）

**任務目標**：調整 LLM 節點以使用檢索到的文件

**節點調整重點**：

**1. 更新系統提示詞**
- [X] 定義 Agent 角色（專業旅遊規劃助理）
- [X] 🆕 說明會提供參考文件
- [X] 🆕 要求優先使用參考文件資訊
- [X] 🆕 如果文件不足，可補充通用知識
- [X] 要求回應簡潔、友善、實用
- [X] 要求使用繁體中文回應

**2. 整合檢索文件到 Prompt**
- [X] 從 `state["retrieved_docs"]` 讀取文件
- [X] 格式化文件內容（每個文件加標題、分隔）
- [X] 注入到訊息列表（在使用者訊息之前）
- [X] 處理無文件情況（正常運作）
- [X] 處理文件過長情況（截斷或摘要）

### 1. 設計與撰寫系統提示詞
- 定義 Agent 角色（專業旅遊規劃助理）
- 說明會提供參考文件，要求優先使用文件資訊
- 文件不足時可補充通用知識
- 要求回應簡潔、友善、實用，並使用繁體中文

### 2. 格式化檢索文件
- 從 `state["retrieved_docs"]` 讀取文件
- 將每個文件加上標題、分隔，格式化成一段文字
- 處理無文件情況（可略過或提示「無相關資料」）
- 處理文件過長情況（可截斷或摘要）

### 3. 整合文件到 Prompt
- 將格式化後的文件內容插入到訊息列表（在使用者訊息之前）
- 設計 Prompt 順序：SystemMessage → 文件資訊 → 使用者問題 → 對話歷史

### 4. 實作 LLM 節點主函數
- 初始化 ChatOpenAI（或其他 LLM）
- 實作 `call_model_node` 函數
  - 讀取 `retrieved_docs`
  - 格式化並注入文件
  - 呼叫 LLM 生成回應
  - 返回狀態更新（如加入 AI 回應到 messages）

### 5. 錯誤處理
- 處理 API 連接失敗、Token 超長、文件格式異常、空文件列表等情況
- 返回友善錯誤訊息

### 6. 單元測試
- 測試有檢索文件時的回應
- 測試無檢索文件時的回應
- 測試文件相關性與回應品質

---

**Prompt 訊息順序設計**：
```
1. SystemMessage（系統提示詞）
2. 🆕 HumanMessage（格式化的參考文件）- 如果有文件
3. HumanMessage（使用者問題）
4. （之前的對話歷史）
5. LLM 生成 AIMessage（回應）
```

**執行步驟**：
- [X] 在 `nodes.py` 實作 LLM 節點
- [X] 初始化 ChatOpenAI
- [X] 實作系統提示詞
- [X] 實作文件格式化函數
- [X] 實作 `call_model_node` 主函數
  - [X] 讀取 retrieved_docs
  - [X] 格式化並注入文件
  - [X] 呼叫 LLM
  - [X] 返回狀態更新
- [X] 加入詳細註解

**文件格式化策略**：
```
如果有文件：
「以下是相關的旅遊資訊參考：

【參考資料 1】
（文件內容）

【參考資料 2】
（文件內容）

【參考資料 3】
（文件內容）

請根據以上資訊回答使用者問題。」
```

**驗證標準**：
- ✅ LLM 節點可讀取 retrieved_docs
- ✅ 文件內容正確注入 Prompt
- ✅ 無文件時仍可正常運作
- ✅ 文件過長時有處理機制

***

### 工作任務 5.2：錯誤處理與測試（30分鐘）

**任務目標**：完善錯誤處理並測試整合效果

**錯誤處理項目**：
- [X] API 連接失敗處理
- [X] Token 超長處理（文件 + 對話超過限制）
- [X] 文件格式異常處理
- [X] 空文件列表處理
- [X] 返回友善錯誤訊息

**測試項目**：
- [X] 有檢索文件時的回應測試
  - 輸入：「推薦台北景點」
  - 預期：回應包含故宮、101 等文件庫內容
- [X] 無檢索文件時的回應測試
  - 輸入：「你好」（無需檢索）
  - 預期：正常問候回應
- [X] 檢索文件相關性測試
  - 確認回應確實使用了文件資訊
  - 確認不是 LLM 的通用知識

**執行步驟**：
- [X] 加入完整錯誤處理
- [X] 實作測試函數
- [X] 執行多種測試案例
- [X] 驗證 RAG 增強效果
- [X] 調整 Prompt（如果需要）

**驗證標準**：
- ✅ 錯誤處理完善
- ✅ 所有測試通過
- ✅ RAG 增強效果明顯
- ✅ 回應基於文件內容
- ✅ 執行 `python nodes.py` 測試通過

***

## 🔗 階段六：Graph 架構建構（1.5-2小時）

### 工作任務 6.1：建立整合 RAG 的 Graph（1.5小時）

**任務目標**：建構 START → RAG → LLM → END 的完整流程

**Graph 架構設計**：
```
START（入口）
  ↓
RAG Node（檢索相關文件）
  - 從向量資料庫檢索
  - 存入 state["retrieved_docs"]
  ↓
LLM Node（基於文件生成回應）
  - 讀取 retrieved_docs
  - 整合文件到 Prompt
  - 生成最終回應
  ↓
END（出口）
```

**執行流程說明**：
1. 使用者輸入問題
2. RAG 節點：檢索相關文件 → 存入 state
3. LLM 節點：讀取文件 → 整合到 Prompt → 生成回應
4. 返回最終結果給使用者

**執行步驟**：
- [ ] 在 `graph.py` 建立 `create_graph` 函數
- [ ] 初始化 `StateGraph(AgentState)`
- [ ] 註冊所有節點
  - [ ] `workflow.add_node("rag", rag_retrieval_node)`
  - [ ] `workflow.add_node("llm", call_model_node)`
- [ ] 定義執行流程（邊）
  - [ ] `workflow.add_edge(START, "rag")`
  - [ ] `workflow.add_edge("rag", "llm")`
  - [ ] `workflow.add_edge("llm", END)`
- [ ] 初始化 MemorySaver（記憶機制）
- [ ] 編譯 Graph：`app = workflow.compile(checkpointer=memory)`
- [ ] 返回編譯後的應用

**記憶機制說明**：
- [ ] MemorySaver 提供 in-memory 狀態持久化
- [ ] 使用 thread_id 識別不同對話 session
- [ ] 同一 thread_id 會共享 state（包含對話歷史）

### 1. 新增 graph.py 檔案
- 在專案根目錄建立 `graph.py`。

### 2. 匯入必要套件與節點
- 匯入 StateGraph、MemorySaver、AgentState
- 匯入 `rag_retrieval_node`、`call_model_node` 節點

### 3. 建立 create_graph 函數
- 初始化 StateGraph(AgentState)
- 註冊所有節點
  - `workflow.add_node("rag", rag_retrieval_node)`
  - `workflow.add_node("llm", call_model_node)`

### 4. 定義執行流程（邊）
- `workflow.add_edge(START, "rag")`
- `workflow.add_edge("rag", "llm")`
- `workflow.add_edge("llm", END)`

### 5. 初始化記憶機制
- 初始化 `MemorySaver`，用於 in-memory 狀態持久化
- 支援 thread_id（session id）管理

### 6. 編譯 Graph
- `app = workflow.compile(checkpointer=memory)`
- 返回編譯後的應用

### 7. 驗證與測試
- 執行簡單測試，確認 RAG → LLM → END 流程正確
- 驗證 state 在節點間正確傳遞
- 驗證 MemorySaver 正常運作

---


**驗證標準**：
- ✅ Graph 成功編譯無錯誤
- ✅ RAG → LLM 流程正確連接
- ✅ 狀態在節點間正確傳遞
- ✅ MemorySaver 正常運作

***

### 工作任務 6.2：Graph 文檔與測試（30分鐘）

**任務目標**：撰寫完整文檔並測試 Graph

**文檔內容**：
- [ ] 當前架構圖（ASCII 格式，包含 RAG）
- [ ] 各節點職責說明
- [ ] 資料流動說明
  - `retrieved_docs` 如何在 RAG → LLM 傳遞
  - `messages` 如何累積
- [ ] 記憶機制說明（Checkpointer、Thread ID）
- [ ] RAG 整合說明
- [ ] 未來擴展規劃（Day 3-4）

**測試項目**：
- [ ] Graph 編譯測試
- [ ] RAG → LLM 流程測試
- [ ] 完整對話測試（含知識檢索）
  - 輸入：「推薦台北景點」
  - 驗證：1) RAG 檢索到文件 2) LLM 使用文件回應
- [ ] 記憶持久化測試（同一 thread_id）
- [ ] 無 RAG 需求測試（例如：「你好」）

**執行步驟**：
- [ ] 撰寫完整架構文檔
- [ ] 在 `graph.py` 加入測試區段
- [ ] 實作所有測試案例
- [ ] 執行測試並驗證輸出
- [ ] 檢查資料流動是否正確

**驗證標準**：
- ✅ 文檔完整清晰
- ✅ 所有測試通過
- ✅ RAG 功能正常運作
- ✅ 狀態傳遞正確
- ✅ 執行 `python graph.py` 測試通過

***

## 💻 階段七：CLI 互動介面開發（1.5小時）

### 工作任務 7.1：建立基礎 CLI 介面（1小時）

**任務目標**：建立友善的命令列互動介面

**CLI 功能需求**：
- [ ] 顯示歡迎訊息與使用提示
- [ ] 初始化 Graph 應用（含 RAG）
- [ ] 產生唯一 session ID（thread_id）
- [ ] 主對話循環
  - 接收使用者輸入
  - 檢查退出命令
  - 執行 Graph
  - 顯示 AI 回應
  - 更新當前狀態
- [ ] 錯誤處理與重試機制
- [ ] 優雅退出

**使用者體驗優化**：
- [ ] 清晰的視覺分隔（= 或 -）
- [ ] 角色標記（👤 使用者、🤖 Agent）
- [ ] 狀態提示（🤔 思考中...、🔍 檢索中...）
- [ ] 錯誤提示（❌ 發生錯誤）
- [ ] 友善的退出訊息（👋 再見！）

**執行步驟**：
- [ ] 在 `main.py` 實作 `main()` 函數
- [ ] 實作歡迎訊息顯示
- [ ] 實作 Graph 初始化
- [ ] 實作主對話循環
- [ ] 加入完整錯誤處理
- [ ] 優化使用者互動體驗
- [ ] 測試各種輸入情境

### 1. 新增 main.py 檔案
- 在專案根目錄建立 `main.py` 作為 CLI 入口。

### 2. 匯入必要套件與模組
- 匯入 `create_graph`（graph.py）、`AgentState`（state.py）、`uuid`（產生 session ID）、`dotenv`（讀取環境變數）。

### 3. 實作歡迎訊息顯示
- 定義 `display_welcome()` 函數，顯示 Agent 名稱、使用提示、退出指令。
- 使用分隔線（`=` 或 `-`）提升可讀性。

### 4. 初始化 Graph 應用
- 呼叫 `create_graph()` 初始化應用。
- 產生唯一 `thread_id`（使用 `uuid.uuid4()`）。

### 5. 主對話循環
- 使用 `while True` 循環接收使用者輸入。
- 檢查退出命令（如 "exit"、"quit"）。
- 建構 `AgentState` 實例，包含使用者訊息。
- 呼叫 `app.invoke()` 執行 Graph，取得回應。
- 顯示 AI 回應（角色標記：👤 使用者、🤖 Agent）。
- 更新狀態以維持對話歷史。

### 6. 錯誤處理與重試機制
- 使用 try/except 捕捉錯誤，顯示友善錯誤訊息（❌ 發生錯誤）。
- 可選：實作重試邏輯（最多 3 次）。

### 7. 使用者體驗優化
- 狀態提示（🤔 思考中...、🔍 檢索中...）。
- 輸出清晰、無亂碼。
- 優雅退出訊息（👋 再見！）。

### 8. 測試各種輸入情境
- 測試正常對話、退出命令、無效輸入、錯誤情境。
- 驗證 session 記憶功能（同一 thread_id 記住上下文）。

### 9. 驗證與調整
- 執行 `python main.py` 測試 CLI 啟動與互動。
- 檢查是否符合驗證標準（正常啟動、可連續對話、退出正常）。

---

**驗證標準**：
- ✅ CLI 可正常啟動
- ✅ 可進行連續對話
- ✅ 退出命令正常運作
- ✅ 錯誤處理完善
- ✅ 使用者體驗良好

***
# TODO
### 工作任務 7.2：增加 DEBUG 模式（30分鐘）

**任務目標**：提供調試模式方便開發與驗證

**DEBUG 功能設計**：
- [ ] 從 `.env` 讀取 `DEBUG_MODE` 設定
- [ ] DEBUG 模式顯示資訊
  - 當前訊息數量
  - 使用者偏好內容
  - 🆕 檢索到的文件數量
  - 🆕 文件來源（檔名）
  - 🆕 相似度分數（可選）
  - 執行的節點名稱（可選）
- [ ] 可切換開啟/關閉
- [ ] 不影響正常使用

**執行步驟**：
- [ ] 在 `.env` 加入 `DEBUG_MODE=False`
- [ ] 在 `main.py` 讀取 DEBUG 設定
- [ ] 實作 DEBUG 資訊顯示函數
- [ ] 在執行 Graph 後顯示 DEBUG 資訊
- [ ] 測試開啟/關閉 DEBUG 模式

**驗證標準**：
- ✅ DEBUG 模式可正常開啟/關閉
- ✅ DEBUG 資訊顯示清晰
- ✅ RAG 相關資訊有助於調試
- ✅ 不影響正常使用體驗

***

## ✅ 階段八：整合測試與驗證（1.5小時）

### 工作任務 8.1：建立完整測試套件（1小時）

**任務目標**：建立涵蓋所有功能的測試套件

**測試函數規劃**：
- [X] `test_state_schema()` - 測試 State 定義（含 RAG 欄位）
- [X] 🆕 `test_vectorstore()` - 測試向量資料庫
- [X] 🆕 `test_rag_node()` - 測試 RAG 檢索節點
- [X] `test_llm_node()` - 測試 LLM 節點（含文件整合）
- [X] `test_single_turn()` - 測試單輪對話（含 RAG）
- [X] 🆕 `test_rag_integration()` - 測試 RAG 整合效果
- [X] `test_multi_turn()` - 測試多輪對話記憶
- [X] `run_all_tests()` - 執行所有測試

**RAG 特定測試案例**：

| 測試項目 | 輸入 | 驗證點 |
|---------|------|--------|
| 台北景點檢索 | 「推薦台北景點」 | 檢索到台北文件、回應包含故宮/101 |
| 東京景點檢索 | 「東京有什麼好玩」 | 檢索到東京文件、回應包含淺草寺 |
| 預算規劃檢索 | 「怎麼規劃預算」 | 檢索到預算指南、回應包含經濟/中等/豪華 |
| 無相關文件 | 「火星旅遊」 | 正常降級回應（LLM 通用知識） |
| 檢索數量 | 任意查詢 | 返回最多 3 個文件 |

**執行步驟**：
- [ ] 在 `test_agent.py` 實作所有測試函數
- [ ] 加入清晰的測試輸出（✅/❌ 標記）
- [ ] 加入測試失敗時的明確訊息
- [ ] 確保測試可重複執行
- [ ] 執行完整測試套件

**驗證標準**：
- ✅ 所有測試函數實作完成
- ✅ 測試覆蓋所有核心功能
- ✅ RAG 功能測試充分
- ✅ 測試輸出清晰易讀

***

### 工作任務 8.2：完整驗收清單執行（30分鐘）

**任務目標**：執行完整功能驗收

**完整驗收檢查清單**：

| 項目 | 驗證方法 | 預期結果 | 完成 |
|------|----------|----------|------|
| **環境設定** | 執行 import 測試 | 所有套件可導入 | [ ] |
| **文件庫** | 檢查 `documents/` 資料夾 | 至少 3 份文件，UTF-8 編碼 | [ ] |
| **向量資料庫** | 檢查 `chroma_db/` 資料夾 | 資料庫已建立，檔案存在 | [ ] |
| **向量檢索** | 執行 `build_vectorstore.py` 測試 | 可正常檢索相關文件 | [ ] |
| **State Schema** | 執行 `python state.py` | 包含 RAG 欄位，測試通過 | [ ] |
| **RAG 節點** | 執行 `python nodes.py` | RAG 測試通過 | [ ] |
| **LLM 節點** | 執行 `python nodes.py` | LLM 測試通過 | [ ] |
| **Graph 編譯** | 執行 `python graph.py` | 含 RAG 流程，編譯成功 | [ ] |
| **單元測試** | 執行 `python test_agent.py` | 所有測試通過 | [ ] |
| **CLI 啟動** | 執行 `python main.py` | 正常啟動，顯示歡迎訊息 | [ ] |
| **基本對話** | 輸入「你好」 | 友善問候回應 | [ ] |
| **知識檢索-台北** | 輸入「推薦台北景點」 | 回應包含文件庫資訊（故宮、101） | [ ] |
| **知識檢索-東京** | 輸入「東京有什麼好玩」 | 回應包含東京文件資訊 | [ ] |
| **知識檢索-預算** | 輸入「怎麼規劃預算」 | 回應參考預算指南文件 | [ ] |
| **文件相關性** | 多個查詢測試 | 檢索結果與查詢相關 | [ ] |
| **降級處理** | 輸入「巴黎有什麼景點」 | 正常回應（即使無文件） | [ ] |
| **中文支援** | 使用中文互動 | 正常顯示無亂碼 | [ ] |
| **退出功能** | 輸入「exit」 | 正常退出 | [ ] |
| **錯誤處理** | 測試無效 API Key | 友善錯誤訊息 | [ ] |
| **記憶功能** | 連續對話 | 記得上下文 | [ ] |
| **DEBUG 模式** | 開啟 DEBUG_MODE | 顯示 RAG 檢索資訊 | [ ] |

**RAG 功能重點驗收**：

**測試 1：知識庫內容驗證**
- [ ] 問：「推薦台北景點」
  - 驗證：回應包含故宮、101、夜市等（文件庫內容）
  - 驗證：不是 LLM 的通用知識
- [ ] 問：「東京有什麼好玩的」
  - 驗證：回應包含淺草寺、晴空塔等（文件庫內容）
- [ ] 問：「旅遊預算怎麼規劃」
  - 驗證：回應參考預算指南（經濟/中等/豪華）

**測試 2：檢索準確性驗證**
- [ ] 確認回應的資訊來自文件庫（對比文件內容）
- [ ] 確認檢索文件與查詢相關
- [ ] 確認檢索數量正確（最多 3 個）
- [ ] 開啟 DEBUG 模式查看檢索到的文件名稱

**測試 3：降級處理驗證**
- [ ] 問不在文件庫的問題（例如：「巴黎有什麼景點」）
  - 驗證：Agent 依然可回應
  - 驗證：會說明沒有相關資料或使用通用知識

**驗證標準**：
- ✅ 所有檢查項目通過
- ✅ RAG 功能正常運作
- ✅ 回應確實基於知識庫
- ✅ 檢索準確性高（>80%）
- ✅ 降級處理正常

***

## 📊 Day 1-2 完成標準

### 功能層面完成標準
- [ ] 可執行 `python main.py` 啟動 Agent
- [ ] 可與 Agent 進行基本對話
- [ ] 🆕 **Agent 回應基於知識庫內容（而非 LLM 幻覺）**
- [ ] 🆕 **可正確檢索相關文件（準確率 >80%）**
- [ ] 🆕 **檢索結果與查詢主題相關**
- [ ] Agent 用繁體中文友善回應
- [ ] Agent 在同一 session 內記住對話歷史
- [ ] 錯誤處理完善，不會輕易崩潰

### 技術層面完成標準
- [ ] 理解 LangGraph 的 State + Node + Edge 架構
- [ ] 理解如何在節點內使用 LangChain 元件
- [ ] 🆕 **理解 RAG 檢索流程（文件 → 向量 → 檢索）**
- [ ] 🆕 **理解向量資料庫運作原理（Embeddings + 相似度搜尋）**
- [ ] 🆕 **理解如何將檢索結果整合到 Prompt**
- [ ] 🆕 **理解節點間資料傳遞（retrieved_docs 如何流動）**
- [ ] 理解 MemorySaver 的記憶機制
- [ ] 理解 thread_id 如何識別對話 session
- [ ] 掌握 Graph 編譯與執行流程

### 產出層面完成標準
- [ ] 完整的專案檔案結構（12+ 個檔案/資料夾）
- [ ] 🆕 **3-5 份旅遊知識文件（UTF-8 編碼）**
- [ ] 🆕 **建置完成的向量資料庫（./chroma_db）**
- [ ] 可執行的程式碼（無語法錯誤）
- [ ] 通過的測試套件（所有測試通過）
- [ ] 完整的文檔與註解
- [ ] 功能正常的 CLI 介面
- [ ] 🆕 **可驗證 RAG 效果的 DEBUG 模式**

### 品質標準
- [ ] 程式碼結構清晰易懂
- [ ] 註解完整詳細
- [ ] 錯誤處理完善
- [ ] 測試覆蓋主要功能
- [ ] 🆕 **RAG 檢索準確率 >80%**
- [ ] 🆕 **回應內容與文件庫一致**
- [ ] 使用者體驗良好

***

## 🎯 Day 3-4 預告

完成 Day 1-2（含 RAG）後，將進入進階功能開發：

### Day 3-4 工作重點
- [ ] **工具整合**：加入景點搜尋 API、行程生成工具
- [ ] **條件分支**：實現「預算不足跳過高級餐廳」邏輯
- [ ] **工具協作**：實現搜尋結果傳遞給行程規劃
- [ ] **錯誤重試**：實現 API 失敗時自動重試 3 次
- [ ] **人機協作**：實現高價訂房前暫停確認

### 技術升級方向
- [ ] Graph 從 3 個節點擴展到 5-7 個節點
- [ ] 加入 Conditional Edges（條件邊）
- [ ] 加入 Human-in-the-Loop 中斷點
- [ ] 整合外部 API（天氣、景點搜尋）

### RAG 優化方向（可選）
- [ ] 增加文件數量（10-20 份）
- [ ] 優化 Chunk 策略（調整 size 和 overlap）
- [ ] 加入 Re-ranking（重新排序檢索結果）
- [ ] 實作混合檢索（向量 + 關鍵字）

***

## 📝 開發建議與注意事項

### 時間管理建議
- [ ] **Day 1 上午**：專注環境設定和文件準備（不要卡太久）
- [ ] **Day 1 下午**：完成 State 設計和 RAG 節點（重點）
- [ ] **Day 2 上午**：完成 LLM 整合和 Graph 建構（核心）
- [ ] **Day 2 下午**：CLI 開發和完整測試（收尾）
- [ ] 如果某階段超時，可適度簡化後續階段

### 品質優先建議
- [ ] **文件品質很重要**：寧可少而精，不要多而雜
- [ ] **測試要充分**：每個階段完成都要測試
- [ ] **註解要清楚**：方便之後維護和擴展
- [ ] **錯誤處理要完整**：避免程式輕易崩潰

### 學習策略建議
- [ ] **邊做邊學**：不要求一開始完全理解
- [ ] **多做實驗**：調整參數看效果（如 chunk_size, k）
- [ ] **記錄問題**：遇到問題記下來，方便討論
- [ ] **保持耐心**：RAG 調教需要時間，不要急

### 降低難度方案
如果覺得困難，可以：
- [ ] 先準備 3 份文件（而非 5 份）
- [ ] 文件內容簡化到 300 字
- [ ] 跳過 DEBUG 模式（先做核心功能）
- [ ] 延後部分測試案例

***

## 🚀 準備開始

**確認清單**：
- [ ] 理解完整開發規劃
- [ ] 確認有 10-12 小時開發時間
- [ ] OpenAI API Key 已準備（且有額度）
- [ ] Python 環境已安裝（>= 3.10）
- [ ] 編輯器已準備（VS Code、PyCharm 或其他）
- [ ] 心理準備：會學到很多新概念！

**開發順序建議**：
1. **先完成階段一**（環境設定）- 打好基礎
2. **再完成階段二**（文件準備）- 確保有資料
3. **逐步實作階段三到八** - 循序漸進
4. **每個階段都驗證** - 確保功能正常
5. **最後整合測試** - 確認整體運作

***

**準備好了嗎？讓我們開始建構具備知識增強能力的旅遊規劃 AI Agent！** 🚀

建議從**階段一的環境設定**開始，有任何問題隨時提問！我會在每個階段提供詳細的程式碼範例和指導。